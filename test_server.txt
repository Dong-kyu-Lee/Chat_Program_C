// 아래 함수는 server.c 일부 내용
#include "header.h"

void *client_process(void *arg) {
    Client *cli = (Client *)arg;
    char buffer[BUFFER_SIZE];
    ssize_t bytes_received;

    get_nickname(cli);
    // If get_nickname failed, cli->sock might be bad or cli->nick is "Guest".
    // The client struct is already added to the global list in main.

    while (cli->sock >= 0) {
        bytes_received = recv(cli->sock, buffer, sizeof(buffer) - 1, 0);

        if (bytes_received <= 0) {
            if (bytes_received == 0) {
                printf("[INFO] Client %s (fd %d) disconnected.\n", cli->nick, cli->sock);
            } else {
                // EAGAIN/EWOULDBLOCK might occur if RCVTIMEO was set and expired.
                // Otherwise, it's a more serious error.
                if (errno != EAGAIN && errno != EWOULDBLOCK) {
                    perror("recv error");
                    printf("[ERROR] Recv error on client %s (fd %d).\n", cli->nick, cli->sock);
                }
            }
            break;
        }
        buffer[bytes_received] = '\0';
        buffer[strcspn(buffer, "\n")] = 0; // Remove trailing newline

        // 클라이언트에서 패킷을 전송할 때 메시지 구조
        // [TYPE_TEXT][length][message]
        // send로 패킷헤더 구조체를 전송한다면, 문자열로 전송이 되나? 아니면 송신자 측에서 전송 타입을 결정할 수 있나?
        // --> 이진 데이터 형태로 전송이 됨.
        if (bytes_received < sizeof(PacketHeader)) {
            safe_send(cli->sock, "[Server] Invalid packet received.\n", TYPE_ERROR);
			printf("[Debug] Received packet too small: %zd bytes\n", bytes_received);
            continue;
        }

        // 패킷 헤더를 읽어오기
        PacketHeader header;
        memcpy(&header, buffer, sizeof(PacketHeader));
        header.length = ntohs(header.length); // Convert length to host byte order
		printf("[DEBUG] Received packet type: %d, length: %d\n", header.type, header.length);

		char* message_start = buffer + sizeof(PacketHeader);
        if (header.length > 0)
		{
			// Ensure the message is null-terminated
			message_start[header.length] = '\0';
		}
        else {
            // Invalid length, skip processing
            safe_send(cli->sock, "[Server] Invalid message length.\n", TYPE_ERROR);
            continue;
        }

	// 타입에 따라 처리...
    }